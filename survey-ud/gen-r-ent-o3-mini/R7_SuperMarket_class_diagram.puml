@startuml

' Define Supermarket and its related classes
class Supermarket {
  +checkInventory()
  +serveCustomer()
}
Supermarket "1" --> "many" Shelf : contains
Supermarket "1" --> "many" Employee : employs
Supermarket "1" --> "many" (Client/Customer) : welcomes
Supermarket "1" --> "1" Cashier : has
Supermarket "1" --> "1" Controller : monitored by

' Shelf holds products
class Shelf {
  +addProduct(p: Product)
  +removeProduct(p: Product)
  +isOccupied() : Boolean
}
Shelf "1" --> "many" Product : displays

' Product and Group
class Product {
  -price : float
  -expirationDate : Date
  -ingredients : String
  +getPrice() : float
  +getExpirationDate() : Date
  +getIngredients() : String
}
class Group {
  +groupName : String
  +listProducts() : void
}
Product "1" --> "1" Group : belongs to

' Client and Customer
class Client {
  +requestAssistance()
  +selectProduct(p: Product)
}
class Customer {
  +makePurchase()
  +pay(amount: float)
}
' We assume both Client and Customer represent persons coming to the supermarket.
Client <|-- Customer

' Employee who helps clients (including chief of order role)
class Employee {
  +assistCustomer()
  +maintainShelf()
}
' Chief of Order is a type of Employee responsible for checking orders.
class ChiefOfOrder {
  +checkOrder(order: Order)
}
Employee <|-- ChiefOfOrder

' Basket holds goods (assume goods are the selected products)
class Basket {
  +addGood(g: Product)
  +removeGood(g: Product)
  +calculateTotal() : float
}
Basket o-- Product : contains

' Cashier, Machine, Controller, and Transaction process
class Cashier {
  +scanProduct(p: Product)
  +processTransaction(t: Transaction)
  +receivePayment(method: String)
  +issueInvoice(i: Invoice)
}
class Machine {
  +enterProduct(p: Product)
  +calculateTotal(products: List<Product>) : float
  +displayTotal(total: float)
}
Cashier --> Machine : uses
class Controller {
  +monitorShelf(s: Shelf)
  +verifyPackaging()
}
class Transaction {
  -total : float
  +addProduct(p: Product)
  +computeTotal() : float
}
Transaction --> Product

' Invoice and Proforma Invoice with Order
class Invoice {
  +generateInvoice()
}
class ProformaInvoice {
  +prepareInvoice()
}
class Order {
  -orders : List<Product>
  +addOrder(p: Product)
  +getOrderList() : List<Product>
}
ProformaInvoice --> Order : includes

' Service represents the delivery process
class Service {
  +initiateDelivery()
  +completeDelivery()
}
Service "1" --> "many" Order : processes

' Relationships among classes
Client "1" --> Basket : uses
Cashier "1" --> Transaction : initiates
Transaction --> Machine : processed by
Cashier "1" --> Invoice : issues
ChiefOfOrder "1" --> ProformaInvoice : validates

@enduml